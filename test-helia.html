<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Test Helia IPFS</title>
  <style>
    body {
      font-family: monospace;
      padding: 20px;
      background: #1a1a1a;
      color: #00ff00;
    }
    .log {
      margin: 10px 0;
      padding: 10px;
      background: #000;
      border-left: 3px solid #00ff00;
    }
    .error {
      border-left-color: #ff0000;
      color: #ff0000;
    }
    .success {
      border-left-color: #00ff00;
      color: #00ff00;
    }
    .info {
      border-left-color: #0088ff;
      color: #0088ff;
    }
    button {
      background: #00ff00;
      color: #000;
      border: none;
      padding: 10px 20px;
      margin: 5px;
      cursor: pointer;
      font-weight: bold;
    }
    button:hover {
      background: #00cc00;
    }
  </style>
</head>
<body>
  <h1>üß™ Test Helia IPFS Connection</h1>
  <div id="logs"></div>
  
  <div style="margin-top: 20px;">
    <button onclick="testHeliaInit()">1Ô∏è‚É£ Test Helia Init</button>
    <button onclick="testTransports()">2Ô∏è‚É£ Test Transports</button>
    <button onclick="testDownload()">3Ô∏è‚É£ Test Download</button>
    <button onclick="testGateway()">4Ô∏è‚É£ Test HTTP Gateway</button>
    <button onclick="clearLogs()">üóëÔ∏è Clear</button>
  </div>

  <script type="module">
    window.logs = [];
    
    function log(message, type = 'info') {
      const logDiv = document.createElement('div');
      logDiv.className = `log ${type}`;
      logDiv.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      document.getElementById('logs').appendChild(logDiv);
      console.log(message);
      window.logs.push({ time: Date.now(), message, type });
    }
    
    window.clearLogs = () => {
      document.getElementById('logs').innerHTML = '';
      window.logs = [];
    };

    // Test 1: Initialize Helia
    window.testHeliaInit = async () => {
      try {
        log('üöÄ Starting Helia initialization test...', 'info');
        
        log('üì¶ Step 1: Importing Helia...', 'info');
        const startImport = Date.now();
        const { createHelia } = await import('helia');
        log(`‚úÖ Helia imported in ${Date.now() - startImport}ms`, 'success');
        
        log('üì¶ Step 2: Importing unixfs...', 'info');
        const { unixfs } = await import('@helia/unixfs');
        log(`‚úÖ unixfs imported`, 'success');
        
        log('‚öôÔ∏è Step 3: Creating Helia instance (minimal config)...', 'info');
        const startCreate = Date.now();
        
        const helia = await createHelia({
          start: true
        });
        
        log(`‚úÖ Helia created in ${Date.now() - startCreate}ms`, 'success');
        
        log('üìä Helia info:', 'info');
        log(`- libp2p: ${helia.libp2p ? 'present' : 'missing'}`, 'info');
        log(`- blockstore: ${helia.blockstore ? 'present' : 'missing'}`, 'info');
        log(`- datastore: ${helia.datastore ? 'present' : 'missing'}`, 'info');
        
        if (helia.libp2p) {
          const peerId = helia.libp2p.peerId.toString();
          log(`- PeerID: ${peerId}`, 'info');
          
          const peers = helia.libp2p.getPeers();
          log(`- Connected peers: ${peers.length}`, peers.length > 0 ? 'success' : 'info');
          
          // Wait for connections
          log('‚è≥ Waiting 5s for peer connections...', 'info');
          await new Promise(resolve => setTimeout(resolve, 5000));
          
          const peersAfter = helia.libp2p.getPeers();
          log(`- Peers after 5s: ${peersAfter.length}`, peersAfter.length > 0 ? 'success' : 'error');
          
          if (peersAfter.length === 0) {
            log('‚ö†Ô∏è No peers connected! Checking transports...', 'error');
            const transports = helia.libp2p.getTransports();
            log(`- Available transports: ${transports.map(t => t.constructor.name).join(', ')}`, 'info');
          }
        }
        
        log('üõë Stopping Helia...', 'info');
        await helia.stop();
        log('‚úÖ Test completed!', 'success');
        
      } catch (error) {
        log(`‚ùå Error: ${error.message}`, 'error');
        log(`Stack: ${error.stack}`, 'error');
      }
    };

    // Test 2: Test with WebSocket transports
    window.testTransports = async () => {
      try {
        log('üöÄ Testing with browser transports...', 'info');
        
        log('üì¶ Importing modules...', 'info');
        const { createHelia } = await import('helia');
        const { unixfs } = await import('@helia/unixfs');
        const { webSockets } = await import('@libp2p/websockets');
        const { bootstrap } = await import('@libp2p/bootstrap');
        log('‚úÖ All modules imported', 'success');
        
        log('‚öôÔ∏è Creating Helia with WebSocket transport...', 'info');
        const helia = await createHelia({
          libp2p: {
            transports: [
              webSockets()
            ],
            peerDiscovery: [
              bootstrap({
                list: [
                  '/dns4/node0.preload.ipfs.io/tcp/443/wss/p2p/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic',
                  '/dns4/node1.preload.ipfs.io/tcp/443/wss/p2p/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6',
                ]
              })
            ],
            connectionManager: {
              maxConnections: 20,
              minConnections: 2
            }
          },
          start: true
        });
        
        log('‚úÖ Helia created with transports', 'success');
        
        const transports = helia.libp2p.getTransports();
        log(`üì° Transports: ${transports.map(t => t.constructor.name).join(', ')}`, 'info');
        
        log('‚è≥ Waiting 10s for connections...', 'info');
        await new Promise(resolve => setTimeout(resolve, 10000));
        
        const peers = helia.libp2p.getPeers();
        log(`üåê Connected to ${peers.length} peer(s)`, peers.length > 0 ? 'success' : 'error');
        
        if (peers.length > 0) {
          peers.forEach((peer, i) => {
            log(`  Peer ${i + 1}: ${peer.toString()}`, 'success');
          });
        }
        
        await helia.stop();
        log('‚úÖ Test completed!', 'success');
        
      } catch (error) {
        log(`‚ùå Error: ${error.message}`, 'error');
        log(`Stack: ${error.stack}`, 'error');
      }
    };

    // Test 3: Test download
    window.testDownload = async () => {
      try {
        log('üöÄ Testing IPFS download...', 'info');
        
        const testCid = 'bafkreif6djrht5navhsmcodf5ewjvfeqxpn62xnywitgebbndnnosl46ey';
        log(`üì• CID to test: ${testCid}`, 'info');
        
        const { createHelia } = await import('helia');
        const { unixfs } = await import('@helia/unixfs');
        const { webSockets } = await import('@libp2p/websockets');
        const { bootstrap } = await import('@libp2p/bootstrap');
        
        const helia = await createHelia({
          libp2p: {
            transports: [webSockets()],
            peerDiscovery: [
              bootstrap({
                list: [
                  '/dns4/node0.preload.ipfs.io/tcp/443/wss/p2p/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic',
                  '/dns4/node1.preload.ipfs.io/tcp/443/wss/p2p/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6',
                ]
              })
            ]
          }
        });
        
        const fs = unixfs(helia);
        
        log('‚è≥ Waiting for peers...', 'info');
        await new Promise(resolve => setTimeout(resolve, 5000));
        
        const peers = helia.libp2p.getPeers();
        log(`üåê ${peers.length} peer(s) connected`, 'info');
        
        log('üì• Starting download...', 'info');
        const startDownload = Date.now();
        
        const decoder = new TextDecoder();
        let content = '';
        
        for await (const chunk of fs.cat(testCid)) {
          content += decoder.decode(chunk, { stream: true });
        }
        
        const downloadTime = Date.now() - startDownload;
        log(`‚úÖ Downloaded ${content.length} bytes in ${downloadTime}ms`, 'success');
        log(`Content preview: ${content.substring(0, 100)}...`, 'info');
        
        await helia.stop();
        
      } catch (error) {
        log(`‚ùå Download error: ${error.message}`, 'error');
        log(`Stack: ${error.stack}`, 'error');
      }
    };

    // Test 4: HTTP Gateway fallback
    window.testGateway = async () => {
      try {
        log('üöÄ Testing HTTP gateway fallback...', 'info');
        
        const testCid = 'bafkreif6djrht5navhsmcodf5ewjvfeqxpn62xnywitgebbndnnosl46ey';
        const gateways = [
          'https://dweb.link/ipfs',
          'https://ipfs.io/ipfs',
          'https://cloudflare-ipfs.com/ipfs'
        ];
        
        for (const gateway of gateways) {
          try {
            log(`üì° Trying ${gateway}...`, 'info');
            const start = Date.now();
            
            const response = await fetch(`${gateway}/${testCid}`, {
              signal: AbortSignal.timeout(5000)
            });
            
            if (!response.ok) {
              log(`‚ùå ${gateway}: HTTP ${response.status}`, 'error');
              continue;
            }
            
            const text = await response.text();
            const time = Date.now() - start;
            log(`‚úÖ ${gateway}: ${text.length} bytes in ${time}ms`, 'success');
            log(`Content preview: ${text.substring(0, 100)}...`, 'info');
            break;
            
          } catch (error) {
            log(`‚ùå ${gateway}: ${error.message}`, 'error');
          }
        }
        
      } catch (error) {
        log(`‚ùå Test error: ${error.message}`, 'error');
      }
    };

    // Auto-run basic test on load
    log('üí° Click buttons to run tests', 'info');
  </script>
</body>
</html>

